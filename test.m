(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["SD`Propagation`",
{"Global`",
"SpinDynamica`",
"General`ModifyBuiltIn`",
"General`Matrices`",
"General`Miscellaneous`",
"QM`Hilbert`",
"QM`SpinOperators`",
"QM`Liouville`",
"QM`SpinSuperoperators`",
"SD`Generators`",
"SD`Approximations`",
"SD`Propagation`",
"Events`Events`",
"Events`PulseSequence`",
"Interactions`Interactions`",
"Interactions`Hamiltonians`",
"Interactions`Relaxation`",
"Signals`Signal`",
"Rotations`Wigner`",
"Units`",
"General`PhysicalConstants`"}];


(* ::Input::Initialization:: *)
Continuous::usage="The option Continuous\[Rule]True may be used in NPropagate or NPropagationOperator to provide an interpolation function which may be evaluated at any time point within the propagation interval.";


(* ::Input::Initialization:: *)
NPropagate::usage="NPropagate[EventsAndTimings, opts][\[Rho]ini] propagates an initial density operator \[Rho]ini under a consecutive sequence of events, returning the final density operator. If \[Rho]ini is a vector representation, the output is also a vector representation. If \[Rho]ini is a symbolic operator, the output is also a symbolic operator. If opts contains Continuous\[Rule]True, the output is a OperatorTrajectoryFunction which may be evaluated at any time point within the timing range of the propagation. The options InitialTimePoint\[Rule]tini or FinalTimePoint\[Rule]tfin may be given to specify the time origin of the event sequence. 

	The item EventsAndTimings is a list of events. The possible formats for each event are:
(i) a single superoperator, assumed to act instantaneously;
(ii) have the form {Hop,\[Tau]} where Hop is a time-independent Hamiltonian operator, acting over the interval \[Tau];
(iii) have the form {Lsop,\[Tau]}, where Lsop is a time-independent Liouvillian superoperator, acting over the interval \[Tau];
(iv) the form {Function[t,f[t]],\[Tau]} where f[t] is an operator or superoperator expression dependent on the time variable t. The time-dependent operator or superoperator acts over the interval \[Tau];
(v) the form {PeriodicFunction[t,T,f[t]],\[Tau]} where f[t] is a periodic operator or superoperator expression with period T.  The periodic time-dependent operator or superoperator acts over the interval \[Tau];
(vi) the form {ShapeFunction[..],\[Tau]} where the ShapeFunction object allows specification of a time-dependent Hamiltonian or Liouvillian dependent on either a global or local time variable, or both. 

	The call to NPropagate may include options for the NDSolve routine, used in cases (iv) and (v). The operator basis used in the calculation may be specified if desired using the OperatorBasis option.
	
	The option EvolutionBackground\[Rule]background may be used in NPropagate. The term background may be an operator, a superoperator, an operator function, and so on (the format is the same as any of the individual events). When this option is used, the term background is combined with all of the items in the sequence of events. 

	The two options UseMatrixExpWhenPossible, UseHilbertSpaceWhenPossible and UseDiagonalizationWhenPossible may be used to control the propagation strategy. These options take the values True or False.

	The output of NPropagate is an operator, for the case Continuous\[Rule]False, or an OperatorTrajectoryFunction, for the case Continuous\[Rule]True.
";


(* ::Input::Initialization:: *)
UseMatrixExpWhenPossible::usage="UseMatrixExpWhenPossible is an option for NPropagate and associated routines. When set to True, propagation will use the matrix exponential to calculate the propagator under a time-independent event, rather than using a numerical solution of the time-dependent Schr\[ODoubleDot]dinger equation.";


(* ::Input::Initialization:: *)
UseDiagonalizationWhenPossible::usage="UseDiagonalizationWhenPossible is an option for NPropagate and associated routines.  When set to True, propagation will diagonalize the Liouvillian or Hamiltonian for a time-independent event, rather than using a numerical solution of the time-dependent Schr\[ODoubleDot]dinger equation.";


(* ::Input::Initialization:: *)
UseHilbertSpaceWhenPossible::usage="UseHilbertSpaceWhenPossible is an option for NPropagate and associated routines.  When set to True, propagation under Hamiltonian events will be calculated in Hilbert space, rather than in Liouville space, whenever possible.";


(* ::Input::Initialization:: *)
NPropagationOperator::usage="NPropagationOperator[events, opts] generates the unitary Operator for propagation under the specified events. The options opts may include a specification for Basis and options to be passed into NDSolve.

The output of NPropagate is an operator, for the case Continuous\[Rule]False, or an OperatorTrajectoryFunction, for the case Continuous\[Rule]True.
";


(* ::Input::Initialization:: *)
NPropagationSuperoperator::usage="NPropagationSuperoperator[EventSpecifications, opts] generates the Superoperator for propagation under the specified EventSpecifications. The options opts may include a specification for OperatorBasis, Basis and options to be passed into NDSolve.";


(* ::Input::Initialization:: *)
OperatorTrajectoryFunction::usage="OperatorTrajectoryFunction[timerange,trajectory] is a function which provides an operator when evaluated at any time point within timerange. It is provided as the output of a NPropagate or NPropagationOperator evaluation with option Continuous\[Rule]True.";


(* ::Input::Initialization:: *)
Precalculate::usage="Precalculate[events, options] calculates the propagator for a set of events and stores it as a PrecalculatedEvent object for future use. The output is a PrecalculatedEvent object. This may save calculation time in some cases. 
The option Precalculate\[Rule]True or Precalculate\[Rule]False is also used as an option for some propagation routines to indicate whether an attempt is made to detect and precalculate common events, in order to reduce computation time.";


(* ::Input::Initialization:: *)
$Chronology="LeftToRight";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
Options[NPropagate]={
OperatorBasis:>DefaultOperatorBasis[],
Basis:>ZeemanBasis[],
Continuous->False,
UseMatrixExpWhenPossible->True,
UseDiagonalizationWhenPossible->Automatic,
UseHilbertSpaceWhenPossible->True,
EvolutionBackground->None,
ExpandRepeatedEvents->Automatic,
PropagatorCalculationProcedure->None,
InitialTimePoint->0,
MaxStepSize->10 10^-6,
MaxSteps->10^6,
Chronology:>$Chronology
};


(* ::Input::Initialization:: *)
SortVectorSpaceCompatibility[ev:EventList[st_,chars_,events:{_Event..},evlistopts___Rule],opts___Rule]:=Module[{eventsig,splitevents},
splitevents=SplitBy[events,HilbertSpaceCompatibility[#,opts]&];
eventsig=(HilbertSpaceCompatibility[#]&/@splitevents);
SortVectorSpaceCompatibility[(Transpose@{eventsig,splitevents})]
]

SortVectorSpaceCompatibility[{A:{__},B:{__}..}]:=Join[SortVectorSpaceCompatibility[A],SortVectorSpaceCompatibility[{B}]];
SortVectorSpaceCompatibility[{stat_,ev:{__}}]:={stat,#}&/@ev;
SortVectorSpaceCompatibility[{{stat_,ev:{__}}}]:={stat,#}&/@ev;


(* ::Input::Initialization:: *)
UHtoUL[A:_Operator,basis_,opts___Rule]:=Module[{Ufw,Ubw},
Ufw=MatrixRepresentation[A,ZeemanBasis[]];
Ubw=If[UnitaryMatrixQ[Ufw]==True,ConjugateTranspose@Ufw,Inverse@Ufw];
Superoperator[KroneckerProduct[Ufw,Transpose@Ubw],ZeemanKetBraOperatorBasis[],basis,
Sequence@@FilterRules[Join[{opts},{CheckOperatorType-> False},Options[NPropagationSuperoperator]],Options[Superoperator]]]
];

UHtoUL[A:_Superoperator,basis_,opts___Rule]:=A;


(* ::Input::Initialization:: *)
NPropagate[arg1:Except[_?BooleanQ|{_?BooleanQ..}],args2___,opts___Rule][\[Rho]_]:=
NPropagate[False,arg1,args2,opts][\[Rho]];


(* ::Input::Initialization:: *)
CheckFlagDimension[NPropagate]=6;


(* ::Input::Initialization:: *)
NPropagate[False,args___][\[Rho]_]:=NPropagate[Table[False,{CheckFlagDimension[NPropagate]}],args][\[Rho]];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,{True..},args___]:=NPropagate[\[Rho],True,args];


(* ::Input::Initialization:: *)
NPropagate[{False,morestatus___},arg1:Except[_?BooleanQ],args2:Except[_Rule]...,opts___Rule][\[Rho]_]:=NPropagate[\[Rho],{OperatorQ[\[Rho]],morestatus},arg1,args2,opts];

NPropagate[\[Rho]_,{False,morestatus___},events_,opts___Rule]:=Module[{},Message[NPropagate::bad\[Rho]];$Failed];


(* ::Input::Initialization:: *)
NPropagate[arg1:Except[True],args___]/;!FreeQ[{arg1,args},$Failed]:=$Failed;


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{_?BooleanQ..},events_,opts___Rule]:=NPropagate[\[Rho],status,
Continuous/.{opts}/.Options[NPropagate],
events,
Sequence@@FilterRules[{opts},Except[Continuous->_]]];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{_?BooleanQ..},cont_?BooleanQ,{},opts___Rule]:=\[Rho];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{_?BooleanQ..},cont_?BooleanQ,events_,opts___Rule]:=
NPropagate[\[Rho],status,cont,events,OperatorBasis/.{opts}/.Options[NPropagate],Basis/.{opts}/.Options[NPropagate],opts];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{_?BooleanQ..},cont_?BooleanQ,events_,opbasis_,basis_,opts___Rule]/;(SpinSystem[]==SpinSystemUnknown):=(Message[SpinSystem::notready];$Failed);


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{_?BooleanQ..},cont_?BooleanQ,events_,opbasis_,basis_,opts___Rule]/;!DefinedOperatorBasisQ[opbasis]:=
(
Message[NPropagate::undefopbasis,opbasis];
NPropagate[\[Rho],status,cont,events,OperatorBasis[],basis,opts]
);


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{_?BooleanQ..},cont_?BooleanQ,events_,opbasis_,basis_,opts___Rule]/;!DefinedBasisQ[basis]:=
(
Message[NPropagate::undefbasis,basis];
NPropagate[\[Rho],status,cont,events,opbasis,Basis[],opts]
);


(* ::Input::Initialization:: *)
HoldPattern@NPropagate[\[Rho]_,status:{True,False,morestatus___},cont_?BooleanQ,events_,opbasis_,basis_,opts___Rule]:=
Module[{evbackg},(
evbackg=StandardizeEvolutionGenerator[EvolutionBackground/.{opts}/.Options[NPropagate]];
NPropagate[\[Rho],{True,True,morestatus},cont,events, opbasis,basis,
Evaluate@SimplifyRules[
EvolutionBackground->
Switch[evbackg,
Except[_Hold|NullEvolutionGeneratorPattern],
	HeldEvolutionGeneratorSymbol[evbackg],
	_,evbackg
],
opts
]
]
)];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{True,True,False,morestatus___},cont_?BooleanQ,events:Except[_PulseSequence],more:(Except[_Rule]...),opts___Rule]/;PulseSequenceQ[events]:=NPropagate[\[Rho],status,cont,PulseSequence[events,opts],more,opts];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{True,True,False,morestatus___},cont_?BooleanQ,events:Except[_EventList],more:(Except[_Rule]...),opts___Rule]:=
NPropagate[\[Rho],
{True,True,False,morestatus},cont,
EventList[events,
SimplifyRules[
Chronology->(Chronology/.{opts}/.Options[NPropagate]),
ImplementEvolutionBackground->True,
ExpandRepeatedEvents->If[cont,True,
ExpandRepeatedEvents/.{opts}/.Options[NPropagate]
],
Sequence@@FilterRules[
Join[{opts},Options[NPropagate]],
Join[Options[EventList],Options[NDSolve]]
]
]
],
more,opts
];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{True,True,False,morestatus___},cont_?BooleanQ,eventlist:EventList[True|{True,_},___],more:(Except[_Rule]...),opts___Rule]:=
NPropagate[\[Rho],{True,True,True,morestatus},cont,eventlist,more,opts];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{True,True,True,False,morestatus___},cont_?BooleanQ,
eventlist_EventList,opbasis_,basis_,opts___Rule]:=
NPropagate[\[Rho],{True,True,True,True,morestatus},cont,HilbertSpaceCompatibility[eventlist],
eventlist,opbasis,basis,opts];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,checkflags:{_,_,_,_,False,morecheckflags__},args___]/;!FreeQ[{args},$Failed]:=$Failed;


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,checkflags:{True,True,True,True,False,morecheckflags__},args___]/;FreeQ[{args},$Failed]:=NPropagate[\[Rho],{True,True,True,True,True,morecheckflags},args];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{True,True,True,True,True,False,morestatus___},cont_?BooleanQ,Hstat_,eventlist:EventList[Except[True|{True..}],___],more___,opts___Rule]:=
Module[{suspsymbols},(
Message[NPropagate::argnotready];
ReportSuspectSymbols[{eventlist,more}];
$Failed
)];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,status:{True,True,True,True,True,False,morestatus___},cont_?BooleanQ,Hstat_,eventlist:EventList[True|{True,True},___],more___]:=NPropagate[\[Rho],{True,True,True,True,True,True,morestatus},cont,Hstat,eventlist,more];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,False,True,EventList[st_,chars_,events:{_Event..},evlistopts___Rule],opbasis_,basis_,opts___Rule]:=Module[{zbmatreps,\[Rho]matrep,zbasis,zobasis,Ufw,Ubw},(
zbasis=ZeemanBasis[];
zobasis=ZeemanKetBraOperatorBasis[];
\[Rho]matrep=MatrixRepresentation[\[Rho],zbasis];
zbmatreps=MatrixRepresentation[NPropagate[True,False,True,#,zobasis,zbasis,opts],zbasis]&/@events;
Ufw=If[Length[zbmatreps]==1,First@zbmatreps,Fold[Dot,First@zbmatreps,Drop[zbmatreps,1]]];
Ubw=If[UnitaryMatrixQ[Ufw]==True,ConjugateTranspose@Ufw,Inverse@Ufw];
Operator[Dot[Ufw,\[Rho]matrep,Ubw],zbasis,Sequence@@FilterRules[{opts},Options[Operator]]]
)];



(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,False,(MixedHilbertSpaceCompatibility|False),ev:EventList[st_,chars_,events:{_Event..},evlistopts___Rule],opbasis_,
basis_,opts___Rule]:=Module[{\[Rho]final,sortedevents,zbmatreps,zbasis,zkbbasis},(
zbasis=ZeemanBasis[];
zkbbasis=ZeemanKetBraOperatorBasis[];
sortedevents=Reverse[SortVectorSpaceCompatibility[ev]];
\[Rho]final=Fold[NPropagate[#1,#2,zkbbasis,zbasis,opts]&,\[Rho],sortedevents]
)];

NPropagate[\[Rho]_,{True,event:_Event},opbasis_,basis_,opts___Rule]:=Module[{\[Rho]mat,Ufw,Ubw},(
\[Rho]mat=MatrixRepresentation[\[Rho],basis];
Ufw=MatrixRepresentation[NPropagate[True,False,True,event,opbasis,basis,opts],basis];
Ubw=If[UnitaryMatrixQ[Ufw]==True,ConjugateTranspose@Ufw,Inverse@Ufw];
Operator[SparseArray@Chop@N@Dot[Ufw,\[Rho]mat,Ubw],basis,Sequence@@FilterRules[{opts},Options[Operator]]
]
)];

NPropagate[\[Rho]_,{False,event:_Event},opbasis_,basis_,opts___Rule]:=Module[{\[Rho]vec,Ufw,Ubw},(
\[Rho]vec=OperatorVectorRepresentation[\[Rho],opbasis];
Ufw=SuperoperatorMatrixRepresentation[NPropagate[True,False,False,event,opbasis,basis,opts],opbasis];
Operator[SparseArray@Chop@N@Dot[Ufw,\[Rho]vec],opbasis,basis,Sequence@@FilterRules[{opts},Options[Operator]]
]
)];


(* ::Input::Initialization:: *)
NPropagate[True,False,True,Event[True|{True,True},{_,_,True,None,__},_,___Rule],opbasis_,basis_,opts___Rule]:=UnityOperator[];


(* ::Input::Initialization:: *)
NPropagate[True,False,True,Event[True|{True,True},{{T_,__},_,True,IntegrateEvolutionOverTime,__},
{_,_},___Rule],opbasis_,basis_,opts___Rule]/;(Chop[T]==0):=UnityOperator[];


(* ::Input::Initialization:: *)
NPropagate[True,False,True,Event[True|{True,True},{{T_,__},_,_,IntegrateEvolutionOverTime,__},{ShapeFunction[___, NullEvolutionGeneratorPattern],_},___Rule],opbasis_,basis_,opts___Rule]:=UnityOperator[];


(* ::Input::Initialization:: *)
NPropagate[True,False,False,Event[True|{True,True},{_,_,True,None,__},_,___Rule],opbasis_,basis_,opts___Rule]:=UnitySuperoperator[];


(* ::Input::Initialization:: *)
NPropagate[True,False,False,Event[True|{True,True},{{T_,__},_,True,IntegrateEvolutionOverTime,__},
{_,_},___Rule],opbasis_,basis_,opts___Rule]/;(Chop[T]==0):=UnitySuperoperator[];


(* ::Input::Initialization:: *)
NPropagate[True,False,False,Event[True|{True,True},{{T_,__},_,_,IntegrateEvolutionOverTime,__},{ShapeFunction[___, NullEvolutionGeneratorPattern],_},___Rule],opbasis_,basis_,opts___Rule]:=UnitySuperoperator[];


(* ::Input::Initialization:: *)
NPropagate[True,False,False,Event[True|{True,True},{_,_,_,InstantaneousTransformation,__},{UnitySuperoperator[___],___},___Rule],opbasis_,basis_,opts___Rule]:=UnitySuperoperator[];


(* ::Input::Initialization:: *)
NPropagate[True,False,True,Event[st:(True|{True,True}),ch:{_,_,_,IntegrateEvolutionOverTime,__},{CommutationSuperoperator[op_,___Rule],\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]:=
NPropagate[True,False,True,Event[st,ch,{op/.{Complex[a_,b_]:>(a-b)},\[Tau]},evopts],opbasis,basis,opts];


(* ::Input::Initialization:: *)
NPropagate[True,False,True,Event[st:(True|{True,True}),ch:{_,_,_,IntegrateEvolutionOverTime,__},{Hop:HoldPattern@Operator[{_?MatrixQ,_List,_?MatrixQ},basis1_,___Rule],\[Tau]_},evopts___Rule],opbasis_,basis2_,opts___Rule]:=
Module[{X,evals,Xinv},(
Hop=If[basis1===basis2,Hop,NDiagonalize[Hop,basis2]];
{X,evals,Xinv}=First@Hop;
Operator[
SparseArray@Chop[X.DiagonalMatrix[Exp[-I*\[Tau]*#]&/@evals].Xinv],
basis2,
Sequence@@FilterRules[
Join[{opts},Options[NPropagate]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagate[True,False,True,Event[st:(True|{True,True}),ch:{_,_,_,IntegrateEvolutionOverTime,__},{Hop_?OperatorQ,\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]/;(UseMatrixExpWhenPossible/.{opts}/.Options[NPropagate]):=
Module[{matrep},(
matrep=MatrixRepresentation[-I Hop* \[Tau]/.{evopts,opts},basis];
Operator[
SparseArray@Chop@N@MatrixExp[N@matrep],
basis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagate]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagate[True,False,True,Event[st:(True|{True,True}),ch:{T_,_,_,IntegrateEvolutionOverTime,__},{Hop_?OperatorQ,\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]/;(!UseMatrixExpWhenPossible/.{opts}/.Options[NPropagate]):=
NPropagate[True,False,True,Event[st,ch,{StandardizeEvolutionGenerator[Function[t,Evaluate[Hop]],Basis->basis],\[Tau]},evopts],opbasis,basis,opts];


(* ::Input::Initialization:: *)
NPropagate[True,False,True,ev:Event[
st:(True|{True,True}),ch_,
{Lfunc:ShapeFunction[t_,\[Tau]xpairs_?MatrixQ,T_,CommutationSuperoperator[op_,___Rule]],\[Tau]_},
evopts___Rule],opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]&&EvolutionBackgroundImplemented[ev]:=
NPropagate[True,False,True,Event[st,ch,{ShapeFunction[t,\[Tau]xpairs,T,op/.{Complex[a_,b_]:>(a-b)}],\[Tau]},evopts],opbasis,basis,opts];


(* ::Input::Initialization:: *)
NPropagate[True,False,True,ev:Event[st:(True|{True,True}),ch:{{_,{tb_,ta_},moretch___},__},{Hfunc:ShapeFunction[t_,\[Tau]xpairs_?MatrixQ,T_,op_?OperatorQ],\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]&&EvolutionBackgroundImplemented[ev]:=Module[{Uini,Ufunc,Hmatfunc,U},
Hmatfunc=Function[t$,Evaluate@N[MatrixRepresentation[Hfunc[t$],basis]]];
Uini=IdentityMatrix[BasisDimension[]];
Ufunc=U/.(Flatten@Chop@NDSolve[{D[U[t$],t$]==-I *Hmatfunc[t$].U[t$],U[ta]==Uini},U,{t$,ta,tb},Sequence@@FilterRules[Join[{evopts,opts},Options[NPropagate]],Options[NDSolve]]]);
Operator[SparseArray@Chop@N[Ufunc[tb]],
basis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagate]],
Options[Operator]
]
]
];


(* ::Input::Initialization:: *)
NPropagate[
True,False,True,
Event[True|{True,True},
{_,_,_,InstantaneousTransformation,__},
{RotationSuperoperator[args___],___},___Rule],opbasis_,
basis_,opts___Rule]:=RotationOperator[args]


(* ::Input::Initialization:: *)
HoldPattern@NPropagate[True,False,True,ev:Event[st:(True|{True,True}),ch_,Repeat[EventList[st_,chars_,events:{_Event..},evlistopts___Rule],n_Integer,evtropts___Rule],
evopts___Rule],opbasis_,basis_,opts___Rule]/;
MatchQ[PropagatorCalculationProcedure[ev],RepeatPropagator]&&EvolutionBackgroundImplemented[ev]:=
Module[{zbmatreps,singleprop},(
zbmatreps=MatrixRepresentation[NPropagate[True,False,True,#,opbasis,basis,opts],basis]&/@events;
singleprop=If[Length[zbmatreps]==1,First@zbmatreps,Fold[Dot,First@zbmatreps,Drop[zbmatreps,1]]];
Operator[MatrixPower[singleprop,n],basis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagate]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagate[True,False,True,ev:Event[st:(True|{True,True}),ch_,PrecalculatedEvent[precalch_,op_Operator,precalevopts___Rule],
evopts___Rule],opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],UsePrecalculatedPropagator]:=op;


(* ::Input::Initialization:: *)
NPropagate[True,False,False,Event[True|{True,True},{_,_,_,InstantaneousTransformation,__},{InstaOp_,___},___Rule],opbasis_,
basis_,opts___Rule]:=InstaOp;


(* ::Input::Initialization:: *)
NPropagate[True,False,False,Event[st:(True|{True,True}),ch:{_,_,_,IntegrateEvolutionOverTime,__},{Lsop:HoldPattern@Superoperator[{_?MatrixQ,_List,_?MatrixQ},opbasis1_,basis1_,___Rule],\[Tau]_},evopts___Rule],opbasis2_,basis2_,opts___Rule]:=
Module[{X,evals,Xinv},(
Lsop=If[opbasis1===opbasis2,Lsop,NDiagonalize[Lsop,opbasis2]];
{X,evals,Xinv}=First@Lsop;
Superoperator[
SparseArray@Chop[X.DiagonalMatrix[Exp[-I*\[Tau]*#]&/@evals].Xinv],
opbasis2,
Sequence@@FilterRules[
Join[{opts},Options[NPropagate]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagate[True,False,False,Event[st:(True|{True,True}),ch:{_,_,_,IntegrateEvolutionOverTime,__},{Lsop_?SuperoperatorQ,\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]/;(UseMatrixExpWhenPossible/.{opts}/.Options[NPropagate]):=Module[{matrep},(
matrep=SuperoperatorMatrixRepresentation[-I (Lsop/.{Complex[a_,b_]:>(a-b)})* \[Tau]/.{evopts,opts},opbasis];
Superoperator[
SparseArray@Chop@N@MatrixExp[N@matrep],
opbasis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagate]],
Options[Operator]
]
]
)
];


(* ::Input::Initialization:: *)
NPropagate[True,False,False,ev:Event[st:(True|{True,True}),ch:{{_,{tb_,ta_},moretch___},__},{Lfunc:ShapeFunction[t_,\[Tau]xpairs_?MatrixQ,T_,op_?SuperoperatorQ],\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]&&EvolutionBackgroundImplemented[ev]:=Module[{Uini,Ufunc,Lmatfunc,U},
Lmatfunc=Function[t$,Evaluate@N[SuperoperatorMatrixRepresentation[(Lfunc/.{Complex[a_,b_]:>(a-b)})[t$],opbasis]]];
Uini=IdentityMatrix[BasisDimension[]*BasisDimension[]];
Ufunc=U/.(Flatten@Chop@NDSolve[{D[U[t$],t$]==-I *Lmatfunc[t$].U[t$],U[ta]==Uini},U,{t$,ta,tb},Sequence@@FilterRules[Join[{evopts,opts},Options[NPropagate]],Options[NDSolve]]]);
Superoperator[SparseArray@Chop@N[Ufunc[tb]],
opbasis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagate]],
Options[Operator]
]
]
];


(* ::Input::Initialization:: *)
HoldPattern@NPropagate[True,False,False,ev:Event[st:(True|{True,True}),ch_,Repeat[EventList[st_,chars_,events:{_Event..},evlistopts___Rule],n_Integer,evtropts___Rule],
evopts___Rule],opbasis_,basis_,opts___Rule]/;
MatchQ[PropagatorCalculationProcedure[ev],RepeatPropagator]&&EvolutionBackgroundImplemented[ev]:=
Module[{matreps,singleprop},(
matreps=SuperoperatorMatrixRepresentation[UHtoUL[NPropagate[True,False,HilbertSpaceCompatibility[#],#,opbasis,basis,opts],basis,opts],opbasis]&/@events;
singleprop=If[Length[matreps]==1,First@matreps,Fold[Dot,First@matreps,Drop[matreps,1]]];
Superoperator[MatrixPower[singleprop,n],opbasis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagate]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagate[True,False,False,ev:Event[st:(True|{True,True}),ch_,PrecalculatedEvent[precalch_,Sop_Superoperator,precalevopts___Rule],
evopts___Rule],opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],UsePrecalculatedPropagator]:=Sop;


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,True,Hstat_,eventlist_EventList,opbasis_,basis_,opts___Rule]:=NPropagate[\[Rho],True,{True,1},eventlist,opbasis,basis,opts];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,
True,{True,1},eventlist_EventList,opbasis_,basis_,opts___Rule]:=
Module[{opfunc,timeinterval},(
timeinterval=TotalEventTimeInterval[eventlist];
opfunc=
NPropagate[\[Rho],True,{True,2},
eventlist,opbasis,basis,opts];
OperatorTrajectoryFunction[{timeinterval},opfunc,opbasis,basis,Sequence@@FilterRules[Join[{opts},Options[NPropagate]],Options[OperatorTrajectoryFunction]]]
)];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,{True,2},
eventlist_EventList,opbasis_,basis_,opts___Rule]:=
Which[
Chop[EventDuration[eventlist]]<=0,
	(Message[NPropagate::contzerodur];$Failed),
!FreeQ[eventlist,_PrecalculatedEvent],
	(Message[NPropagate::contnoprecalev];$Failed),
True,
	NPropagate[\[Rho],True,{True,3},eventlist,opbasis,basis,opts]
];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,{True,3},
eventlist:EventList[st_,ch_,events:{_Event..},evlistopts___Rule],opbasis_,basis_,opts___Rule]:=Module[{sortedevents,zbasis,funcsLtoR,timeintervalsLtoR,intervals,funcs,lasttimepoint},(
timeintervalsLtoR=Reverse[Reverse/@EventTimeIntervals[eventlist]];
sortedevents=Reverse[SortVectorSpaceCompatibility[eventlist]];
funcsLtoR=Drop[#,1]&@FoldList[NPropagate[#1[InitialTimePoint[#2[[2]]]],True,{True,4},#2,opbasis,basis,opts]&,Function[\[Rho]],sortedevents];
{intervals,funcs}=Transpose@Cases[Transpose[{timeintervalsLtoR,funcsLtoR}],{{_,_},_InterpolatingFunction|_Function}];
If[
FreeQ[{timeintervalsLtoR,funcsLtoR},$Failed],
({intervals,funcs}=Transpose@Cases[Transpose[{timeintervalsLtoR,funcsLtoR}],{{_,_},_InterpolatingFunction|_Function}];
Function[t,
Evaluate@Chop[
N@Piecewise[
MapThread[{#1[t],#2}&,
{funcs,
Join[
(#[[1]]<=t<#[[2]])&/@Most[intervals],
(#[[1]]<=t<=#[[2]])&/@{Last[intervals]}
]
}
],
Undefined
]
]
]
),
$Failed
]
)];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,{True,4},
{True,ev:Event[st:True|{True..},ch_,{CommutationSuperoperator[op_,___Rule],\[Tau]_},evopts___Rule]},opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]:=NPropagate[\[Rho],True,{True,4},{True,Event[st,ch,{op/.{Complex[a_,b_]:>(a-b)},\[Tau]},evopts]},opbasis,basis,opts];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,{True,4},
{True,ev:Event[st:True|{True..},ch_,{Hop_?OperatorQ,\[Tau]_},evopts___Rule]},opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]:=Module[{tb,ta,\[Rho]matrep,t,evals,evecs,X,Xinv},(
\[Rho]matrep=MatrixRepresentation[\[Rho],basis];
{tb,ta}={FinalTimePoint[ev],InitialTimePoint[ev]};
Function[t,
Evaluate@Operator[
{X,evals,Xinv}=First@NDiagonalize[Hop,basis,opts];
SparseArray@Chop@N@ExpToTrig@Normal[Dot[#,\[Rho]matrep,ConjugateTranspose@#]&@
(MultiplyMatricesAndMatrixInterpolationFunctions[
X,
DiagonalMatrix[Exp[-I*#*(t-ta)]&/@evals],
Xinv
])
],
basis,CheckOperatorType->False
]
]
)];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,{True,4},{True,ev:Event[st:(True|{True,True}),ch_,
{ShapeFunction[t_,\[Tau]xpairs_?MatrixQ,T_,CommutationSuperoperator[op_,___Rule]],\[Tau]_},
evopts___Rule]},opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]&&EvolutionBackgroundImplemented[ev]:=
NPropagate[\[Rho],True,{True,4},{True,Event[st,ch,
{ShapeFunction[t,\[Tau]xpairs,T,op/.{Complex[a_,b_]:>(a-b)}],\[Tau]},evopts]},opbasis,basis,opts];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,{True,4},{True,ev:Event[st:True|{True..},ch_,{Hfunc:ShapeFunction[args__,op_?OperatorQ],\[Tau]_},evopts___Rule]},opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]:=
Module[{dim,tb,ta,Hmatfunc,NDSolveopts,\[Rho]mat,\[Rho]func,\[Rho]$,\[Rho]opfunc,FlattenIfunc},(
FlattenIfunc[ifunc_InterpolatingFunction]/;(Depth[ifunc]>=3)&&
MatchQ[ifunc[ifunc[[1,1,1]]],_?MatrixQ]:=
Replace[ifunc,{m_?MatrixQ:> Flatten[m]},{3}];
dim=BasisDimension[];
\[Rho]mat=MatrixRepresentation[\[Rho],ZeemanBasis[]];
{tb,ta}={FinalTimePoint[ev],InitialTimePoint[ev]};
Hmatfunc=Function[t$,Evaluate[N@Normal@MatrixRepresentation[Hfunc[t$,ta,tb]/.{evopts,opts},basis]]];
NDSolveopts=Sequence@@FilterRules[{evopts,opts},Options[NDSolve]];
\[Rho]func=\[Rho]$/.(First@NDSolve[{D[\[Rho]$[t$],t$]==-I(Hmatfunc[t$].\[Rho]$[t$]-\[Rho]$[t$].Hmatfunc[t$]),\[Rho]$[ta]==Normal@\[Rho]mat},\[Rho]$,{t$,ta,tb},Sequence@@FilterRules[Join[{evopts,opts},Options[NPropagate]],Options[NDSolve]]]);
\[Rho]func=FlattenIfunc[\[Rho]func];
Function[t,Evaluate@Operator[\[Rho]func[t],ZeemanKetBraOperatorBasis[],ZeemanBasis[],CheckOperatorType->False]]
)];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,{True,4},{True,ev:Event[True|{True,True},
{_,_,_,InstantaneousTransformation,__},
{RotationSuperoperator[args___],___},___Rule]},opbasis_,
basis_,opts___Rule]:=
Module[{Ufw,\[Rho]matrep},(
\[Rho]matrep=MatrixRepresentation[\[Rho],basis];
Ufw=MatrixRepresentation[RotationOperator[args],basis];
Function[t,
Evaluate@Operator[
Dot[Ufw,\[Rho]matrep,ConjugateTranspose@Ufw],basis,Sequence@@FilterRules[Join[{opts},Options[NPropagate]],Options[Operator]]]
]
)];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,{True,4},{False,Event[True|{True,True},{_,_,_,InstantaneousTransformation,__},{InstaOp_,___},___Rule]},opbasis_,basis_,opts___Rule]:=Module[{Ufw,\[Rho]vec},(
\[Rho]vec=OperatorVectorRepresentation[\[Rho],opbasis];
Ufw=SuperoperatorMatrixRepresentation[InstaOp,opbasis];
Function[t,
Evaluate@Operator[
Dot[Ufw,\[Rho]vec],opbasis,basis,Sequence@@FilterRules[Join[{opts},Options[NPropagate]],Options[Operator]]]
]
)];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,{True,4},{False,ev:Event[st:(True|{True,True}),ch:{_,_,_,IntegrateEvolutionOverTime,__},{Lsop_?SuperoperatorQ,\[Tau]_},evopts___Rule]},opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]:=Module[{\[Rho]vec,ta,tb,t,evals,X,Xinv},(
\[Rho]vec=OperatorVectorRepresentation[\[Rho],opbasis];
{tb,ta}={FinalTimePoint[ev],InitialTimePoint[ev]};
Function[t,
Evaluate@Operator[
{X,evals,Xinv}=First@NDiagonalize[Lsop,opbasis,opts];
SparseArray@Chop@N@ExpToTrig@Normal[Dot[(MultiplyMatricesAndMatrixInterpolationFunctions[X,DiagonalMatrix[Exp[-I*#*(t-ta)]&/@evals],Xinv]),\[Rho]vec]],opbasis,basis,CheckOperatorType->False]]
)];


(* ::Input::Initialization:: *)
NPropagate[\[Rho]_,True,{True,4},{False,ev:Event[st:True|{True..},ch:{{_,{tb_,ta_},moretch___},__},{Lfunc:ShapeFunction[t_,\[Tau]xpairs_?MatrixQ,T_,op_?SuperoperatorQ],\[Tau]_},evopts___Rule]},opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]&&EvolutionBackgroundImplemented[ev]:=Module[{\[Rho]vec,\[Rho]func,\[Rho]$,Lmatfunc},
Lmatfunc=Function[t$,Evaluate@N[SuperoperatorMatrixRepresentation[Lfunc[t$],opbasis]]];
\[Rho]vec=OperatorVectorRepresentation[\[Rho],opbasis];
\[Rho]func=\[Rho]$/.(Flatten@Chop@NDSolve[{D[\[Rho]$[t$],t$]==-I *Lmatfunc[t$].\[Rho]$[t$],\[Rho]$[ta]==Normal@\[Rho]vec},\[Rho]$,{t$,ta,tb},Sequence@@FilterRules[Join[{evopts,opts},Options[NPropagate]],Options[NDSolve]]]);
Function[t$,Evaluate@Operator[\[Rho]func[t$],opbasis,basis,CheckOperatorType->False]]
];


(* ::Input::Initialization:: *)
NPropagate::argnotready="The argument of NPropagate is not ready for numerical computation.";


(* ::Input::Initialization:: *)
NPropagate::undefbasis="The Basis `1` is not defined. Calculation will proceed using the default Basis.";


(* ::Input::Initialization:: *)
NPropagate::undefopbasis="The OperatorBasis `1` is not defined. Calculation will proceed using the default OperatorBasis.";


(* ::Input::Initialization:: *)
NPropagate::nonnumeric="A non-numeric matrix was detected. The requested context does not permit operators with symbolic coefficients.";


(* ::Input::Initialization:: *)
NPropagate::contzerodur="NPropagate with the option setting Continuous\[Rule]True requires an event duration greater than 0.";


(* ::Input::Initialization:: *)
NPropagate::contnoprecalev="Precalculated events are not allowed for NPropagate with the option setting Continuous\[Rule]True.";


(* ::Input::Initialization:: *)
NPropagate::bad\[Rho]="NPropagate was applied to an expression that is not an operator.";


(* ::Input::Initialization:: *)
Options[NPropagationOperator]={
OperatorBasis:>DefaultOperatorBasis[],
Basis:>ZeemanBasis[],
Continuous-> False,
UseMatrixExpWhenPossible->True,
EvolutionBackground->None,
ExpandRepeatedEvents->Automatic,
PropagatorCalculationProcedure->None,
InitialTimePoint->0,
Chronology:>$Chronology,
Assumptions->{OperatorType->"Unitary"},
CheckOperatorType->False
};


(* ::Input::Initialization:: *)
NPropagationOperator[arg1:Except[_?BooleanQ|{_?BooleanQ..}],args2___,opts___Rule]:=
NPropagationOperator[False,arg1,args2,opts];


(* ::Input::Initialization:: *)
CheckFlagDimension[NPropagationOperator]=5;


(* ::Input::Initialization:: *)
NPropagationOperator[False,args___]:=
NPropagationOperator[Table[False,{CheckFlagDimension[NPropagationOperator]}],args];


(* ::Input::Initialization:: *)
NPropagationOperator[{True..},args___]:=
NPropagationOperator[True,args];


(* ::Input::Initialization:: *)
NPropagationOperator[arg1:Except[True],args___]/;!FreeQ[{arg1,args},$Failed]:=$Failed;


(* ::Input::Initialization:: *)
NPropagationOperator[False|{_?BooleanQ..},arg1:Except[_?BooleanQ],args2:Except[_Rule]...,opts___Rule]:=
NPropagationOperator[False,
Continuous/.{opts}/.Options[NPropagationOperator],
arg1,args2,
Sequence@@FilterRules[{opts},Except[Continuous->_]]
];


(* ::Input::Initialization:: *)
NPropagationOperator[status:{_?BooleanQ..},cont_?BooleanQ,{},basis_,opts___Rule]:=UnityOperator[];


(* ::Input::Initialization:: *)
NPropagationOperator[status:{_?BooleanQ..},cont_?BooleanQ,events_,opts___Rule]:=
NPropagationOperator[status,cont,events,Basis/.{opts}/.Options[NPropagationOperator],opts];


(* ::Input::Initialization:: *)
NPropagationOperator[status:{_?BooleanQ..},cont_?BooleanQ,events_,basis_,opts___Rule]/;(SpinSystem[]==SpinSystemUnknown):=(Message[SpinSystem::notready];$Failed);


(* ::Input::Initialization:: *)
NPropagationOperator[status:{_?BooleanQ..},cont_?BooleanQ,events_,BasisUnknown,opts___Rule]:=
(
Message[Basis::unknown];
Message[Basis::default];
SetBasis[ZeemanBasis[SpinSystem[]],CheckBasis->False];
NPropagationOperator[status,cont,events,opts]
);


(* ::Input::Initialization:: *)
NPropagationOperator[status:{_?BooleanQ..},cont_?BooleanQ,events_,basis_,opts___Rule]/;!DefinedBasisQ[basis]:=
(
Message[NPropagationOperator::undefbasis,basis];
NPropagationOperator[status,cont,events,Basis[],opts]
);


(* ::Input::Initialization:: *)
HoldPattern@NPropagationOperator[status:{False,morestatus___},cont_?BooleanQ,events_,basis_,opts___Rule]:=
Module[{evbackg},(
evbackg=StandardizeEvolutionGenerator[EvolutionBackground/.{opts}/.Options[NPropagationOperator]];
NPropagationOperator[{True,morestatus},cont,events, basis,
Evaluate@SimplifyRules[
EvolutionBackground->
Switch[evbackg,
Except[_Hold|NullEvolutionGeneratorPattern],
	HeldEvolutionGeneratorSymbol[evbackg],
	_,evbackg
],
opts
]
]
)];


(* ::Input::Initialization:: *)
NPropagationOperator[status:{True,False,morestatus___},cont_?BooleanQ,events:Except[_PulseSequence],more:(Except[_Rule]...),opts___Rule]/;PulseSequenceQ[events]:=NPropagationOperator[status,cont,PulseSequence[events,opts],more,opts];


(* ::Input::Initialization:: *)
NPropagationOperator[status:{True,False,morestatus___},cont_?BooleanQ,events:Except[_EventList],more:(Except[_Rule]...),opts___Rule]:=
NPropagationOperator[
{True,False,morestatus},cont,
EventList[events,
SimplifyRules[
Chronology->(Chronology/.{opts}/.Options[NPropagationOperator]),
ImplementEvolutionBackground->True,
ExpandRepeatedEvents->If[cont,True,
ExpandRepeatedEvents/.{opts}/.Options[NPropagationOperator]
],
Sequence@@FilterRules[
Join[{opts},Options[NPropagationOperator]],
Join[Options[EventList],Options[NDSolve]]
]
]
],
more,opts
];


(* ::Input::Initialization:: *)
NPropagationOperator[status:{True,False,morestatus___},cont_?BooleanQ,eventlist:EventList[True|{True,_},___],more:(Except[_Rule]...),opts___Rule]:=
NPropagationOperator[{True,True,morestatus},cont,eventlist,more,opts];


(* ::Input::Initialization:: *)
NPropagationOperator[status:{True,True,False,morestatus___},cont_?BooleanQ,
eventlist_EventList,basis_,opts___Rule]/;(!TrueQ[HilbertSpaceCompatibility[eventlist,opts]]):=
(Message[NPropagationOperator::hilbincompat];$Failed);


(* ::Input::Initialization:: *)
NPropagationOperator[status:{True,True,False,morestatus___},cont_?BooleanQ,
eventlist_EventList,basis_,opts___Rule]/;(TrueQ[HilbertSpaceCompatibility[eventlist,opts]]):=
NPropagationOperator[{True,True,True,morestatus},cont,
eventlist,basis,opts];


(* ::Input::Initialization:: *)
NPropagationOperator[checkflags:{_,_,_,False,morecheckflags__},args___]/;!FreeQ[{args},$Failed]:=$Failed;


(* ::Input::Initialization:: *)
NPropagationOperator[checkflags:{True,True,True,False,morecheckflags__},args___]/;FreeQ[{args},$Failed]:=NPropagationOperator[{True,True,True,True,morecheckflags},args];


(* ::Input::Initialization:: *)
NPropagationOperator[status:{True,True,True,True,False,morestatus___},cont_?BooleanQ,eventlist:EventList[Except[True|{True..}],___],more___,opts___Rule]:=
Module[{suspsymbols},(
Message[NPropagationOperator::argnotready];
ReportSuspectSymbols[{eventlist,more}];
$Failed
)];


(* ::Input::Initialization:: *)
NPropagationOperator[status:{True,True,True,True,False,morestatus___},cont_?BooleanQ,eventlist:EventList[True|{True,True},___],more___]:=NPropagationOperator[{True,True,True,True,True,morestatus},cont,eventlist,more];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
EventList[st_,chars_,events:{_Event..},evlistopts___Rule],
basis_,opts___Rule]:=
Module[{zbmatreps,zbasis},(
zbasis=ZeemanBasis[];
zbmatreps=MatrixRepresentation[
NPropagationOperator[True,False,#,zbasis,opts],
zbasis
]&/@events;
Operator[
If[Length[zbmatreps]==1,First@zbmatreps,Fold[Dot,First@zbmatreps,Drop[zbmatreps,1]]],
zbasis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationOperator]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
Event[True|{True,True},
{_,_,True,None,__},
_,___Rule],
basis_,
opts___Rule
]:=UnityOperator[];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
Event[True|{True,True},
{{T_,__},_,True,IntegrateEvolutionOverTime,__},
{_,_},___Rule],
basis_,
opts___Rule
]/;(Chop[T]==0):=UnityOperator[];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
Event[True|{True,True},
{{T_,__},_,_,IntegrateEvolutionOverTime,__},
{ShapeFunction[___, NullEvolutionGeneratorPattern],_},___Rule],
basis_,
opts___Rule
]:=UnityOperator[];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
Event[True|{True,True},
{_,_,_,InstantaneousTransformation,__},
{UnitySuperoperator[___],___},___Rule],
basis_,
opts___Rule
]:=UnityOperator[];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
Event[True|{True,True},
{_,_,_,InstantaneousTransformation,__},
{RotationSuperoperator[args___],___},___Rule],
basis_,opts___Rule]:=RotationOperator[args];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
Event[st:(True|{True,True}),
ch:{_,_,_,IntegrateEvolutionOverTime,__},
{CommutationSuperoperator[minusIop_,___Rule],\[Tau]_},evopts___Rule],
basis_,opts___Rule]:=
NPropagationOperator[
True,False,
Event[st,ch,{minusIop/.{Complex[a_,b_]:>(a-b)},\[Tau]},evopts],basis,opts];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
Event[st:(True|{True,True}),
ch:{_,_,_,IntegrateEvolutionOverTime,__},
{Hop:HoldPattern@Operator[{_?MatrixQ,_List,_?MatrixQ},opbasis_,___Rule],\[Tau]_},evopts___Rule],
basis_,
opts___Rule]:=
Module[{X,evals,Xinv},(
{X,evals,Xinv}=First@NDiagonalize[Hop,opbasis];
Operator[
SparseArray@Chop[X.DiagonalMatrix[Exp[-I*\[Tau]*#]&/@evals].Xinv],
opbasis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationOperator]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
Event[st:(True|{True,True}),
ch:{_,_,_,IntegrateEvolutionOverTime,__},
{Hop_?OperatorQ,\[Tau]_},evopts___Rule],
basis_,
opts___Rule]/;(UseMatrixExpWhenPossible/.{opts}/.Options[NPropagationOperator]):=
Module[{matrep,zbasis},(
zbasis=ZeemanBasis[];
matrep=MatrixRepresentation[-I Hop* \[Tau]/.{evopts,opts},zbasis];
Operator[
SparseArray@N@Chop@MatrixExp[N@matrep],
zbasis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationOperator]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
Event[st:(True|{True,True}),
ch:{T_,_,_,IntegrateEvolutionOverTime,__},
{Hop_?OperatorQ,\[Tau]_},evopts___Rule],
basis_,opts___Rule]/;(!UseMatrixExpWhenPossible/.{opts}/.Options[NPropagationOperator]):=
NPropagationOperator[
True,False,
Event[
st,ch,
{StandardizeEvolutionGenerator[
Function[t,Evaluate[Hop]],
Basis->basis
],
\[Tau]},
evopts
],
basis,
opts];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
ev:Event[
st:(True|{True,True}),ch_,
{ShapeFunction[t_,\[Tau]xpairs_?MatrixQ,T_,CommutationSuperoperator[op_,___Rule]],\[Tau]_},
evopts___Rule],
basis_,
opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]&&EvolutionBackgroundImplemented[ev]:=
NPropagationOperator[
True,False,
Event[
st,ch,
{ShapeFunction[t,\[Tau]xpairs,T,op/.{Complex[a_,b_]:>(a-b)}],\[Tau]},evopts],
basis,
opts];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
ev:Event[
st:(True|{True,True}),
ch:{{_,{tb_,ta_},moretch___},__},
{Hfunc:ShapeFunction[t_,\[Tau]xpairs_?MatrixQ,T_,op_?OperatorQ],\[Tau]_},
evopts___Rule
],
basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]&&EvolutionBackgroundImplemented[ev]:=
Module[{n,u,uvec,umat,h,hvec,hmat,t$,maineqns,initialconds,Hmatfunc,NDSolveopts},(
Hmatfunc=
Function[t$,
Evaluate[
Normal@MatrixRepresentation[Hfunc[t$,ta,tb]/.{evopts,opts},basis]
]
];
n=BasisDimension[basis];
uvec[t$_]=Through[Flatten[Array[u,{n,n}]][t$]];
hmat[t$_]=Partition[Through[Flatten[Array[h,{n,n}]][t$]],n];
umat[t$_]=Partition[uvec[t$],n];
maineqns=Inner[(#1==#2)&,D[uvec[t$],t$],Flatten[-I (hmat[t$].umat[t$])],List];
initialconds=Flatten[umat[ta]/.{u[r_,r_][_]:>u[r,r][ta]==1,u[r_,s_][_]:>u[r,s][ta]==0}];
Operator[
Partition[
NDSolveValue[
Join[
maineqns/.h[r_,s_][t$_]:>Hmatfunc[t$][[r,s]],
initialconds
],
uvec[t$],
{t$,ta,tb},
Sequence@@FilterRules[Join[{evopts,opts},Options[NPropagationOperator]],Options[NDSolveValue]]
]/.t$->tb,
n
],
Sequence@@FilterRules[
Join[{opts},Options[NPropagationOperator]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
HoldPattern@NPropagationOperator[
True,False,
ev:Event[
st:(True|{True,True}),ch_,
Repeat[evlist_EventList,n_Integer,evtropts___Rule],
evopts___Rule
],
basis_,
opts___Rule
]/;
MatchQ[PropagatorCalculationProcedure[ev],RepeatPropagator]&&EvolutionBackgroundImplemented[ev]:=
Module[{zbasis},(
zbasis=ZeemanBasis[];
Operator[
MatrixPower[
MatrixRepresentation[NPropagationOperator[True,False,evlist,zbasis,opts],zbasis],
n
],
zbasis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationOperator]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,False,
ev:Event[
st:(True|{True,True}),ch_,
PrecalculatedEvent[precalch_,op_Operator,precalevopts___Rule],
evopts___Rule
],
basis_,
opts___Rule
]/;MatchQ[PropagatorCalculationProcedure[ev],UsePrecalculatedPropagator]:=
op;


(* ::Input::Initialization:: *)
NPropagationOperator[status:{_?BooleanQ..},False,
eventlists:{_EventList..},basis_,opts___Rule]:=
Operator[
Apply[Dot,
MatrixRepresentation[
NPropagationOperator[status,False,#,basis,opts],
basis
]&/@eventlists
],
basis,
Sequence@@FilterRules[Join[{opts},Options[NPropagationOperator]],Options[Operator]]
];


(* ::Input::Initialization:: *)
NPropagationOperator[True,True,eventlist_EventList,basis_,opts___Rule]:=NPropagationOperator[True,{True,1},eventlist,basis,opts];


(* ::Input::Initialization:: *)
NPropagationOperator[
True,{True,1},eventlist_EventList,basis_,opts___Rule]:=
Module[{opfunc,timeinterval,opbasis},(
opbasis=OperatorBasis/.{opts}/.Options[NPropagationOperator];
timeinterval=TotalEventTimeInterval[eventlist];
opfunc=
NPropagationOperator[True,{True,2},
eventlist,opbasis,basis,opts
];
OperatorTrajectoryFunction[{timeinterval},opfunc,opbasis,basis,Sequence@@FilterRules[Join[{opts},Options[NPropagationOperator]],Options[OperatorTrajectoryFunction]]]
)];


(* ::Input::Initialization:: *)
NPropagationOperator[True,{True,2},
eventlist_EventList,opbasis_,basis_,opts___Rule]:=
Which[
Chop[EventDuration[eventlist]]<=0,
	(Message[NPropagationOperator::contzerodur];$Failed),
!TrueQ[HilbertSpaceCompatibility[eventlist,opts]],
	(Message[NPropagationOperator::hilbincompat];$Failed),
!FreeQ[eventlist,_PrecalculatedEvent],
	(Message[NPropagationOperator::contnoprecalev];$Failed),
True,
	NPropagationOperator[True,{True,3},eventlist,opbasis,basis,opts]
];


(* ::Input::Initialization:: *)
HoldPattern@NPropagationOperator[True,{True,3},
eventlist:EventList[st_,ch_,events:{_Event..},evlistopts___Rule],opbasis_,basis_,opts___Rule]:=Module[{funcsLtoR,timeintervalsLtoR,intervals,funcs,lasttimepoint,InitialPropagator,n},(
timeintervalsLtoR=Reverse[Reverse/@EventTimeIntervals[eventlist]];
funcsLtoR=Drop[#,1]&@
FoldList[
NPropagationOperator[True,{True,4},#1[InitialTimePoint[#2]],#2,opbasis,basis,opts]&,
Function[UnityOperator[]],
Reverse@events
];
{intervals,funcs}=Transpose@Cases[Transpose[{timeintervalsLtoR,funcsLtoR}],{{_,_},_InterpolatingFunction|_Function}];
If[
FreeQ[{timeintervalsLtoR,funcsLtoR},$Failed],
({intervals,funcs}=Transpose@Cases[Transpose[{timeintervalsLtoR,funcsLtoR}],{{_,_},_InterpolatingFunction|_Function}];
Function[t,
Evaluate@Chop[
N@Piecewise[
MapThread[{#1[t],#2}&,
{funcs,
Join[
(#[[1]]<=t<#[[2]])&/@Most[intervals],
(#[[1]]<=t<=#[[2]])&/@{Last[intervals]}
]
}
],
Undefined
]
]
]
),
$Failed
]
)];


(* ::Input::Initialization:: *)
NPropagationOperator[True,{True,4},InitialPropagator_,
ev:Event[st:True|{True..},ch_,
{Hop_?OperatorQ,\[Tau]_},evopts___Rule],
opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]:=Module[{tb,ta,Umatini,t,evals,evecs,X,Xinv},(
{tb,ta}={FinalTimePoint[ev],InitialTimePoint[ev]};
Umatini=MatrixRepresentation[InitialPropagator,basis];
Function[t,
Evaluate@Operator[
{X,evals,Xinv}=First@NDiagonalize[Hop,basis,opts];
SparseArray@Chop@N@ExpToTrig@Normal[
MultiplyMatricesAndMatrixInterpolationFunctions[
X,
DiagonalMatrix[Exp[-I*#*(t-ta)]&/@evals],
Xinv,
Umatini
]
],
basis,CheckOperatorType->False
]
]
)];


(* ::Input::Initialization:: *)
NPropagationOperator[True,{True,4},InitialPropagator_,
ev:Event[st:True|{True..},ch_,
{Hfunc:ShapeFunction[args__,op_?OperatorQ],\[Tau]_},evopts___Rule
],
opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]:=
Module[{tb,ta,Hmatfunc,NDSolveopts},(
{tb,ta}={FinalTimePoint[ev],InitialTimePoint[ev]};
Hmatfunc=
Function[tinternal,
Evaluate[
Normal@MatrixRepresentation[Hfunc[tinternal,ta,tb]/.{evopts,opts},basis]
]
];
NDSolveopts=Sequence@@FilterRules[{evopts,opts},Options[NDSolve]];
EvolvePropagator[Hmatfunc,InitialPropagator,{tb,ta},opbasis,basis,NDSolveopts]
)];


(* ::Input::Initialization:: *)

HoldPattern@EvolvePropagator[Hmatfunc_,InitialPropagator_,{tb_,ta_},opbasis_,basis_,NDSolveopts___Rule]:=
Module[{Ufunc,Uini,U},
Uini=MatrixRepresentation[InitialPropagator,basis];
Ufunc=U/.(Flatten@Chop@NDSolve[{D[U[t],t]==-I *Hmatfunc[t].U[t],U[ta]== Normal[Uini]},U,{t,ta,tb},NDSolveopts]);
Ufunc=Function[t,Evaluate@Operator[Ufunc[t],basis,CheckOperatorType-> False]]
];


(* ::Input::Initialization:: *)
NPropagationOperator[True,{True,4},InitialPropagator_,ev:Event[st:True|{True..},ch_,evspec_,evopts___Rule],
opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],InstantaneousTransformation]:=
Module[{matrep,Umatini},(
Umatini=MatrixRepresentation[InitialPropagator,basis];
matrep=MatrixRepresentation[
NPropagationOperator[evspec,Continuous->False],basis];
Function[
Operator[
Dot[matrep,Umatini],Sequence@@FilterRules[Join[{opts},Options[NPropagationOperator]],Options[Operator]]]
]
)];


(* ::Input::Initialization:: *)
NPropagationOperator::argnotready="The argument of NPropagationOperator is not ready for numerical computation.";


(* ::Input::Initialization:: *)
NPropagationOperator::undefbasis="The basis `1` is not defined. Calculation will proceed using the default basis.";


(* ::Input::Initialization:: *)
NPropagationOperator::hilbincompat="Cannot calculate the propagation operator of a Hilbert-space-incompatible event.";


(* ::Input::Initialization:: *)
NPropagationOperator::nonnumeric="A non-numeric matrix was detected. The requested context does not permit operators with symbolic coefficients.";


(* ::Input::Initialization:: *)
NPropagationOperator::contzerodur="NPropagationOperator with the option setting Continuous\[Rule]True requires an event duration greater than 0.";


(* ::Input::Initialization:: *)
NPropagationOperator::contnoprecalev="Precalculated events are not allowed for NPropagationOperator with the option setting Continuous\[Rule]True.";


(* ::Input::Initialization:: *)
Options[NPropagationSuperoperator]={
OperatorBasis:>DefaultOperatorBasis[],
Basis:>ZeemanBasis[],
UseHilbertSpaceWhenPossible->True,
UseMatrixExpWhenPossible->True,
EvolutionBackground->None,
ExpandRepeatedEvents->Automatic,
PropagatorCalculationProcedure->None,
InitialTimePoint->0,
Chronology:>$Chronology,
Assumptions->{},
CheckSuperoperatorType->False
};


(* ::Input::Initialization:: *)
NPropagationSuperoperator[arg1:Except[_?BooleanQ|{_?BooleanQ..}],args2___,opts___Rule]:=
NPropagationSuperoperator[False,arg1,args2,opts];


(* ::Input::Initialization:: *)
CheckFlagDimension[NPropagationSuperoperator]=5;


(* ::Input::Initialization:: *)
NPropagationSuperoperator[False,args___]:=NPropagationSuperoperator[Table[False,{CheckFlagDimension[NPropagationSuperoperator]}],args];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[{True..},args___]:=NPropagationSuperoperator[True,args];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[arg1:Except[True],args___]/;!FreeQ[{arg1,args},$Failed]:=$Failed;


(* ::Input::Initialization:: *)
NPropagationSuperoperator[status:{_?BooleanQ..},{},opbasis_,basis_,opts___Rule]:=UnitySuperoperator[];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[status:{_?BooleanQ..},events_,opts___Rule]:=NPropagationSuperoperator[status,events,OperatorBasis/.{opts}/.Options[NPropagationSuperoperator],Basis/.{opts}/.Options[NPropagationSuperoperator],opts];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[status:{_?BooleanQ..},events_,opbasis_,basis_,opts___Rule]/;(SpinSystem[]==SpinSystemUnknown):=(Message[SpinSystem::notready];$Failed);


(* ::Input::Initialization:: *)
NPropagationSuperoperator[status:{_?BooleanQ..},events_,opbasis_,basis_,opts___Rule]/;!DefinedOperatorBasisQ[opbasis]:=
(
Message[NPropagationSuperoperator::undefopbasis,opbasis];
NPropagationSuperoperator[status,events,OperatorBasis[],Basis[],opts]
);


(* ::Input::Initialization:: *)
NPropagationSuperoperator[status:{_?BooleanQ..},events_,opbasis_,basis_,opts___Rule]/;!DefinedBasisQ[basis]:=
(
Message[NPropagationSuperoperator::undefbasis,basis];
NPropagationSuperoperator[status,events,opbasis,Basis[],opts]
);


(* ::Input::Initialization:: *)
HoldPattern@NPropagationSuperoperator[status:{False,morestatus___},events_,opbasis_,basis_,opts___Rule]:=
Module[{evbackg},(
evbackg=StandardizeEvolutionGenerator[EvolutionBackground/.{opts}/.Options[NPropagationSuperoperator]];
NPropagationSuperoperator[{True,morestatus},events,opbasis, basis,
Evaluate@SimplifyRules[
EvolutionBackground->
Switch[evbackg,
Except[_Hold|NullEvolutionGeneratorPattern],
	HeldEvolutionGeneratorSymbol[evbackg],
	_,evbackg
],
opts
]
]
)];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[status:{True,False,morestatus___},events:Except[_PulseSequence],more:(Except[_Rule]...),opts___Rule]/;PulseSequenceQ[events]:=NPropagationSuperoperator[status,PulseSequence[events,opts],more,opts];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[status:{True,False,morestatus___},events:Except[_EventList],more:(Except[_Rule]...),opts___Rule]:=
NPropagationSuperoperator[
{True,False,morestatus},
EventList[events,
SimplifyRules[
Chronology->(Chronology/.{opts}/.Options[NPropagationSuperoperator]),
ImplementEvolutionBackground->True,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationSuperoperator]],
Join[Options[EventList],Options[NDSolve]]
]
]
],
more,opts
];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[status:{True,False,morestatus___},eventlist:EventList[True|{True,_},___],more:(Except[_Rule]...),opts___Rule]:=
NPropagationSuperoperator[{True,True,morestatus},eventlist,more,opts];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[status:{True,True,False,morestatus___},
eventlist_EventList,opbasis_,basis_,opts___Rule]:=
NPropagationSuperoperator[{True,True,True,morestatus},HilbertSpaceCompatibility[eventlist],eventlist,opbasis,basis,opts];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[checkflags:{_,_,_,False,morecheckflags__},args___]/;!FreeQ[{args},$Failed]:=$Failed;


(* ::Input::Initialization:: *)
NPropagationSuperoperator[checkflags:{True,True,True,False,morecheckflags__},args___]/;FreeQ[{args},$Failed]:=
NPropagationSuperoperator[{True,True,True,True,morecheckflags},args];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[status:{True,True,True,True,False,morestatus___},Hstat_,eventlist:EventList[Except[True|{True..}],___],more___,opts___Rule]:=
Module[{suspsymbols},(
Message[NPropagationSuperoperator::argnotready];
ReportSuspectSymbols[{eventlist,more}];
$Failed
)];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[status:{True,True,True,True,False,morestatus___},Hstat_,eventlist:EventList[True|{True,True},___],more___]:=
NPropagationSuperoperator[{True,True,True,True,True,morestatus},Hstat,eventlist,more];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,EventList[st_,chars_,events:{_Event..},evlistopts___Rule],opbasis_,basis_,opts___Rule]:=Module[{Hfunc,zbmatreps,zbasis,zobasis,Ufw,Ubw},(
zobasis=ZeemanKetBraOperatorBasis[];
zbasis=ZeemanBasis[];
zbmatreps=
MatrixRepresentation[NPropagationSuperoperator[True,True,#,zobasis,zbasis,opts],zbasis]&/@events;
Ufw=If[Length[zbmatreps]==1,First@zbmatreps,Fold[Dot,First@zbmatreps,Drop[zbmatreps,1]]];
Ubw=If[UnitaryMatrixQ[Ufw]==True,ConjugateTranspose@Ufw,Inverse@Ufw];
Superoperator[KroneckerProduct[Ufw,Transpose@Ubw],ZeemanKetBraOperatorBasis[],zbasis,
Sequence@@FilterRules[Join[{opts},{CheckOperatorType-> False},Options[NPropagationSuperoperator]],Options[Superoperator]]]
)];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,(False|MixedHilbertSpaceCompatibility),ev:EventList[st_,chars_,events:{_Event..},evlistopts___Rule],opbasis_,
basis_,opts___Rule]:=Module[{U,Umatreps,sortedevents,zbasis,zobasis},(
zbasis=ZeemanBasis[];
zobasis=ZeemanKetBraOperatorBasis[];
sortedevents=Reverse[SortVectorSpaceCompatibility[ev]];
Umatreps=(SuperoperatorMatrixRepresentation[UHtoUL[NPropagationSuperoperator[True,Sequence@@#,zobasis,basis,opts],zobasis,opts],zobasis]&/@sortedevents);
U=If[Length[Umatreps]==1,First@Umatreps,Fold[Dot,First@Umatreps,Drop[Umatreps,1]]];
Superoperator[U,zobasis,zbasis,
Sequence@@FilterRules[Join[{opts},{CheckOperatorType-> False},Options[NPropagationSuperoperator]],Options[Superoperator]]]
)];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,Event[True|{True,True},{_,_,True,None,__},_,___Rule],opbasis_,basis_,opts___Rule]:=UnityOperator[];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,Event[True|{True,True},{{T_,__},_,True,IntegrateEvolutionOverTime,__},
{_,_},___Rule],opbasis_,basis_,opts___Rule]/;(Chop[T]==0):=UnityOperator[];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,Event[True|{True,True},
{{T_,__},_,_,IntegrateEvolutionOverTime,__},{ShapeFunction[___, NullEvolutionGeneratorPattern],_},___Rule],opbasis_,basis_,opts___Rule]:=UnityOperator[];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,False,Event[True|{True,True},{_,_,True,None,__},_,___Rule],opbasis_,basis_,opts___Rule]:=Superoperator[UnitySuperoperator[],opbasis,CheckOperatorType-> False];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,False,Event[True|{True,True},{{T_,__},_,True,IntegrateEvolutionOverTime,__},
{_,_},___Rule],opbasis_,basis_,opts___Rule]/;(Chop[T]==0):=Superoperator[UnitySuperoperator[],opbasis,CheckOperatorType-> False];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,False,Event[True|{True,True},
{{T_,__},_,_,IntegrateEvolutionOverTime,__},{ShapeFunction[___, NullEvolutionGeneratorPattern],_},___Rule],opbasis_,basis_,opts___Rule]:=Superoperator[UnitySuperoperator[],opbasis,CheckOperatorType-> False];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,False,False,Event[True|{True,True},{_,_,_,InstantaneousTransformation,__},{UnitySuperoperator[___],___},___Rule],opbasis_,basis_,opts___Rule]:=Superoperator[UnitySuperoperator[],opbasis,CheckOperatorType-> False];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,Event[st:(True|{True,True}),ch:{_,_,_,IntegrateEvolutionOverTime,__},{CommutationSuperoperator[op_,___Rule],\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]:=
NPropagationSuperoperator[True,True,Event[st,ch,{op/.{Complex[a_,b_]:>(a-b)},\[Tau]},evopts],opbasis,basis,opts];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,Event[st:(True|{True,True}),ch:{_,_,_,IntegrateEvolutionOverTime,__},{Hop:HoldPattern@Operator[{_?MatrixQ,_List,_?MatrixQ},basis1_,___Rule],\[Tau]_},evopts___Rule],opbasis_,basis2_,opts___Rule]:=
Module[{X,evals,Xinv},(
Hop=If[basis1==basis2,Hop,NDiagonalize[Hop,basis2]];
{X,evals,Xinv}=First@Hop;
Operator[SparseArray@Chop@N[X.DiagonalMatrix[Exp[-I*\[Tau]*#]&/@evals].Xinv],basis2,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationSuperoperator]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,Event[st:(True|{True,True}),ch:{_,_,_,IntegrateEvolutionOverTime,__},{Hop_?OperatorQ,\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]/;(UseMatrixExpWhenPossible/.{opts}/.Options[NPropagationSuperoperator]):=
Module[{matrep},(
matrep=MatrixRepresentation[-I Hop* \[Tau]/.{evopts,opts},basis];
Operator[SparseArray@Chop@N@MatrixExp[N@matrep],
Sequence@@FilterRules[
Join[{opts},Options[NPropagationSuperoperator]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,Event[st:(True|{True,True}),ch:{T_,_,_,IntegrateEvolutionOverTime,__},{Hop_?OperatorQ,\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]/;(!UseMatrixExpWhenPossible/.{opts}/.Options[NPropagationSuperoperator]):=
NPropagationSuperoperator[True,True,Event[st,ch,{StandardizeEvolutionGenerator[Function[t,Evaluate[Hop]],Basis->basis],\[Tau]},evopts],opbasis,basis,opts];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,ev:Event[st:(True|{True,True}),ch_,{ShapeFunction[t_,\[Tau]xpairs_?MatrixQ,T_,CommutationSuperoperator[op_,___Rule]],\[Tau]_},
evopts___Rule],opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]&&EvolutionBackgroundImplemented[ev]:=
NPropagationSuperoperator[True,True,Event[st,ch,{ShapeFunction[t,\[Tau]xpairs,T,op/.{Complex[a_,b_]:>(a-b)}],\[Tau]},evopts],opbasis,basis,opts];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,ev:Event[st:(True|{True,True}),ch:{{_,{tb_,ta_},moretch___},__},{Hfunc:ShapeFunction[t_,\[Tau]xpairs_?MatrixQ,T_,op_?OperatorQ],\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]&&EvolutionBackgroundImplemented[ev]:=Module[{Uini,Ufunc,Hmatfunc,U},
Hmatfunc=Function[t$,Evaluate@N[MatrixRepresentation[Hfunc[t$],basis]]];
Uini=IdentityMatrix[BasisDimension[]];
Ufunc=U/.(Flatten@Chop@NDSolve[{D[U[t$],t$]==-I *Hmatfunc[t$].U[t$],U[ta]==Uini},U,{t$,ta,tb},Sequence@@FilterRules[Join[{evopts,opts},Options[NPropagate]],Options[NDSolve]]]);
Operator[SparseArray@Chop@N[Ufunc[tb]],
basis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationSuperoperator]],
Options[Operator]
]
]
];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,Event[True|{True,True},{_,_,_,InstantaneousTransformation,__},{RotationSuperoperator[args___],___},___Rule],opbasis_,basis_,opts___Rule]:=RotationOperator[args]


(* ::Input::Initialization:: *)
HoldPattern@NPropagationSuperoperator[True,True,ev:Event[st:(True|{True,True}),ch_,Repeat[EventList[st_,chars_,events:{_Event..},evlistopts___Rule],n_Integer,evtropts___Rule],
evopts___Rule],opbasis_,basis_,opts___Rule]/;
MatchQ[PropagatorCalculationProcedure[ev],RepeatPropagator]&&EvolutionBackgroundImplemented[ev]:=
Module[{zbmatreps,singleprop},(
zbmatreps=MatrixRepresentation[NPropagationSuperoperator[True,True,#,opbasis,basis,opts],basis]&/@events;
singleprop=If[Length[zbmatreps]==1,First@zbmatreps,Fold[Dot,First@zbmatreps,Drop[zbmatreps,1]]];
Operator[MatrixPower[singleprop,n],basis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationSuperoperator]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,True,ev:Event[st:(True|{True,True}),ch_,PrecalculatedEvent[precalch_,op_Operator,precalevopts___Rule],
evopts___Rule],opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],UsePrecalculatedPropagator]:=op;


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,False,Event[True|{True,True},{_,_,_,InstantaneousTransformation,__},{InstaOp_,___},___Rule],opbasis_,basis_,opts___Rule]:=Superoperator[InstaOp,opbasis,CheckOperatorBasis-> False];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,False,Event[st:(True|{True,True}),ch:{_,_,_,IntegrateEvolutionOverTime,__},{Lsop:HoldPattern@Superoperator[{_?MatrixQ,_List,_?MatrixQ},opbasis1_,basis1_,___Rule],\[Tau]_},evopts___Rule],opbasis2_,basis2_,opts___Rule]:=
Module[{X,evals,Xinv},(
Lsop=If[opbasis1===opbasis2,Lsop,NDiagonalize[Lsop,opbasis2]];
{X,evals,Xinv}=First@Lsop;
Superoperator[
SparseArray@Chop[X.DiagonalMatrix[Exp[-I*\[Tau]*#]&/@evals].Xinv],
opbasis2,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationSuperoperator]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,False,Event[st:(True|{True,True}),ch:{_,_,_,IntegrateEvolutionOverTime,__},{Lsop_?SuperoperatorQ,\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]/;(UseMatrixExpWhenPossible/.{opts}/.Options[NPropagationSuperoperator]):=Module[{matrep},(
matrep=SuperoperatorMatrixRepresentation[-I (Lsop/.{Complex[a_,b_]:>(a-b)})* \[Tau]/.{evopts,opts},opbasis];
Superoperator[
SparseArray@Chop@N@MatrixExp[N@matrep],
opbasis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationSuperoperator]],
Options[Operator]
]
]
)
];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,False,ev:Event[st:(True|{True,True}),ch:{{_,{tb_,ta_},moretch___},__},{Lfunc:ShapeFunction[t_,\[Tau]xpairs_?MatrixQ,T_,op_?SuperoperatorQ],\[Tau]_},evopts___Rule],opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],IntegrateEvolutionOverTime]&&EvolutionBackgroundImplemented[ev]:=Module[{Uini,Ufunc,Lmatfunc,U},
Lmatfunc=Function[t$,Evaluate@N[SuperoperatorMatrixRepresentation[(Lfunc/.{Complex[a_,b_]:>(a-b)})[t$],opbasis]]];
Uini=IdentityMatrix[BasisDimension[]*BasisDimension[]];
Ufunc=U/.(Flatten@Chop@NDSolve[{D[U[t$],t$]==-I *Lmatfunc[t$].U[t$],U[ta]==Uini},U,{t$,ta,tb},Sequence@@FilterRules[Join[{evopts,opts},Options[NPropagate]],Options[NDSolve]]]);
Superoperator[SparseArray@Chop@N[Ufunc[tb]],
opbasis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationSuperoperator]],
Options[Operator]
]
]
];


(* ::Input::Initialization:: *)
HoldPattern@NPropagationSuperoperator[True,False,ev:Event[st:(True|{True,True}),ch_,Repeat[EventList[st_,chars_,events:{_Event..},evlistopts___Rule],n_Integer,evtropts___Rule],
evopts___Rule],opbasis_,basis_,opts___Rule]/;
MatchQ[PropagatorCalculationProcedure[ev],RepeatPropagator]&&EvolutionBackgroundImplemented[ev]:=
Module[{matreps,singleprop},(
matreps=SuperoperatorMatrixRepresentation[UHtoUL[NPropagationSuperoperator[True,HilbertSpaceCompatibility[#],#,opbasis,basis,opts],basis,opts],opbasis]&/@events;
singleprop=If[Length[matreps]==1,First@matreps,Fold[Dot,First@matreps,Drop[matreps,1]]];
Superoperator[MatrixPower[singleprop,n],opbasis,
Sequence@@FilterRules[
Join[{opts},Options[NPropagationSuperoperator]],
Options[Operator]
]
]
)];


(* ::Input::Initialization:: *)
NPropagationSuperoperator[True,False,ev:Event[st:(True|{True,True}),ch_,PrecalculatedEvent[precalch_,Sop_Superoperator,precalevopts___Rule],evopts___Rule],opbasis_,basis_,opts___Rule]/;MatchQ[PropagatorCalculationProcedure[ev],UsePrecalculatedPropagator]:=Sop;


(* ::Input::Initialization:: *)
NPropagationSuperoperator::argnotready="The argument of NPropagationSuperoperator is not ready for numerical computation.";


(* ::Input::Initialization:: *)
NPropagationSuperoperator::undefopbasis="The OperatorBasis `1` is not defined. Calculation will proceed using the default OperatorBasis.";


(* ::Input::Initialization:: *)
NPropagationSuperoperator::undefbasis="The basis `1` is not defined. Calculation will proceed using the default basis.";


(* ::Input::Initialization:: *)
Options[Precalculate]=
{
InitialTimePoint->0,
FinalTimePoint->Automatic,
EvolutionBackground->Undefined,
PropagatorCalculationProcedure->Automatic,
ExpandRepeatedEvents->Automatic,
Verbose->False
};


(* ::Input::Initialization:: *)
Precalculate[args___]/;!FreeQ[{args},$Failed]:=$Failed;


(* ::Input::Initialization:: *)
Precalculate[events:Except[_EventList],opts___Rule]:=
Precalculate[
EventList[events,
SimplifyRules[
opts,
Sequence@@Options[Precalculate]
]
],
opts
];


(* ::Input::Initialization:: *)
Precalculate[evlist:EventList[False|{False,_},___],opts___Rule]/;MatchQ[EvolutionBackground[evlist],Undefined]:=
(Message[Precalculate::nobackg];$Failed);


(* ::Input::Initialization:: *)
Precalculate[evlist:EventList[False|{False,_},___],opts___Rule]/;MatchQ[InitialTimePoint[evlist],Undefined]:=
(Message[Precalculate::nota];$Failed);


(* ::Input::Initialization:: *)
Precalculate[evlist:EventList[False|{False,_},___],opts___Rule]/;MatchQ[FinalTimePoint[evlist],Undefined]:=
(Message[Precalculate::notb];$Failed);


(* ::Input::Initialization:: *)
Precalculate[evlist:EventList[True|{True,__},evlistch_,___],opts___Rule]:=
Module[{},(
PrecalculatedEvent[
evlistch,
If[HilbertSpaceCompatibility[evlist],
NPropagationOperator[evlist,
SimplifyRules[Continuous->False,opts]
],
NPropagationSuperoperator[evlist,
SimplifyRules[Continuous->False,opts]
]
],
Sequence@@FilterRules[{opts},Options[PrecalculatedEvent]]
]
)];


(* ::Input::Initialization:: *)
Precalculate::nobackg="Precalculate requires a defined EvolutionBackground.";


(* ::Input::Initialization:: *)
Precalculate::nota="Precalculate requires a defined InitialTimePoint.";


(* ::Input::Initialization:: *)
Precalculate::nota="Precalculate requires a defined FinalTimePoint.";


(* ::Input::Initialization:: *)
Options[OperatorTrajectoryFunction]={};


(* ::Input::Initialization:: *)
OperatorTrajectoryFunction[args___]/;!FreeQ[{args},$Failed]:=$Failed;


(* ::Input::Initialization:: *)
OperatorTrajectoryFunction[range:{{tb_?NumericQ,ta_?NumericQ}},opfunc_,opts___Rule]:=OperatorTrajectoryFunction[range,opfunc,OperatorBasis[],opts];


(* ::Input::Initialization:: *)
OperatorTrajectoryFunction[range:{{tb_?NumericQ,ta_?NumericQ}},opfunc_,opbasis_,opts___Rule]:=OperatorTrajectoryFunction[range,opfunc,opbasis,Basis[],opts];


(* ::Input::Initialization:: *)
Format[OperatorTrajectoryFunction[range:{{tb_?NumericQ,ta_?NumericQ}},opfunc_,opbasis_,basis_,opts___Rule]]:=
RowBox[{
"OperatorTrajectoryFunction[",
ToBoxes[EngineeringForm@Chop[N@(Reverse/@range)]
],
ToBoxes[", <>]"]
}]//DisplayForm;


(* ::Input::Initialization:: *)
OperatorTrajectoryFunction[{{tb_?NumericQ,ta_?NumericQ}},opfunc:Except[_String],opbasis_,basis_,opts___Rule][t_?NumericQ]/;(Chop@N[t-ta]<0)||(Chop@N[t-tb]>0):=
(
Message[
OperatorTrajectoryFunction::outofrange,
EngineeringForm[N@t],EngineeringForm[N@ta],EngineeringForm[N@tb]
];
0);


(* ::Input::Initialization:: *)
OperatorTrajectoryFunction[{{tb_?NumericQ,ta_?NumericQ}},opfunc:Except[_String],opbasis_,basis_,opts___Rule][t_?NumericQ]:=Chop@ExpressOperator[opfunc[t],opbasis];


(* ::Input::Initialization:: *)
InitialTimePoint[OperatorTrajectoryFunction[{{tb_?NumericQ,ta_?NumericQ}},___]]:=ta;


(* ::Input::Initialization:: *)
FinalTimePoint[OperatorTrajectoryFunction[{{tb_?NumericQ,ta_?NumericQ}},___]]:=tb;


(* ::Input::Initialization:: *)
OperatorTrajectoryFunction::outofrange="time point `1` does not lie in the interval between `2` and `3`";


(* ::Input::Initialization:: *)
End[];
EndPackage[];



